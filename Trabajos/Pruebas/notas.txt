int x = 5;
int[] t;
t = new int[];
t = new int[30];
x = t.length;
t[30] = 200;
t[29] = 200;
int[] tt = t;
tt[29] = 1;

¿Cuantas matrices hay?
tt = new int[3];
Una matriz [0, 0, 0]

¿Cuántas zonas de memoria hay reservadas?
¿Cuántos arrays hay?
t[29] = 666;
tt[29] = -1;
tt[2] = -1;
Si los arrays t y tt se declararon en otra parte del código (por ejemplo, int[] t = new int[30]; y int[] tt = new int[30];), entonces se reservan 2 zonas de memoria, una para t y otra para tt.
Como se mencionaron las variables t y tt, podemos asumir que hay 2 arrays en total: t y tt.
Memoria reservado = 2
Arrays o matrices creadas = 2

if (t == tt){
    (...)
}

t = new int[] {1,1,2,5};
tt = new int[] {1,1,2,5};

if (t==tt){
    (...)
}

¿Cuántas zonas se reservan?
new int[10];
Esta línea crea un nuevo array de tipo int con 10 elementos. Esto significa que se reserva 1 zona de memoria para este array. Sin embargo, este array no tiene una variable asignada para almacenarlo, por lo que no se puede acceder directamente a él (a menos que se lo asigne a una variable, como int[] a = new int[10]

int[] a;
Aquí solo se declara una variable de tipo array, pero no se le asigna memoria aún. No se ha reservado ninguna zona de memoria, porque solo es una declaración.

int[] a = new int[10];
En esta línea, se declara la variable a y se le asigna un array de 10 elementos de tipo int. Esto reserva 1 zona de memoria para el array y otra para la referencia de la variable a. Así que en total, se reservan 2 zonas de memoria (una para el array y otra para la variable a).

int[][] a = new [10][100];
Este es un array bidimensional, por lo que crea un array de 10 elementos, y cada uno de esos 10 elementos es otro array que tiene 100 elementos de tipo int.
Se reserva 1 zona de memoria para el array de 10 elementos, y 10 zonas de memoria adicionales para cada uno de los arrays internos de tamaño 100, lo que da un total de 11 zonas de memoria reservadas.

Formalmente
final int[][] GRID = new int[][] { 
    new int[] { -1, 0 }, 
    new int[] { 1, 0 }, 
    new int[] { 0, -1 }, 
    new int[] { 0, 1 } 
};

Pero gracias a la inferencia de tipos, podemos hacer
final int[][] GRID = { 
    { -1, 0 }, 
    { 1, 0 }, 
    { 0, -1 }, 
    { 0, 1 } 
};

Lo que simplifica matrices más grandes:
final int[][] BIG_GRID = {
   {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
   {0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
   {1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1},
   {1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1},
   {1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,1},
   {1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1},
   {1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1},
   {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
   {1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1},
   {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1}
};
```java